---
layout: post
title: "Girard"
date: 2025-10-24
---

# polymorphic types

You can of couse say polymorphic. But I think of more that. First the
syntax using CFG or BNF

![A : : = X \\mid \\mathsf{ans} \\mid A_1 \\to A_2 \\mid \\forall (X. A)](https://latex.codecogs.com/svg.image?A%20%3A%20%3A%20%3D%20X%20%5Cmid%20%5Cmathsf%7Bans%7D%20%5Cmid%20A_1%20%5Cto%20A_2%20%5Cmid%20%5Cforall%20%28X.%20A%29 "A : : = X \mid \mathsf{ans} \mid A_1 \to A_2 \mid \forall (X. A)")

![M : : = x \\mid \\mathsf{yes} \\mid \\mathsf{no}\\mid \\lambda(x.M)\\mid \\mathsf{ap}(M_1 ; M_2) \\mid \\Lambda(X. M) \\mid \\mathsf{Ap}(M ; A)](https://latex.codecogs.com/svg.image?M%20%3A%20%3A%20%3D%20x%20%5Cmid%20%5Cmathsf%7Byes%7D%20%5Cmid%20%5Cmathsf%7Bno%7D%5Cmid%20%5Clambda%28x.M%29%5Cmid%20%5Cmathsf%7Bap%7D%28M_1%20%3B%20M_2%29%20%5Cmid%20%5CLambda%28X.%20M%29%20%5Cmid%20%5Cmathsf%7BAp%7D%28M%20%3B%20A%29 "M : : = x \mid \mathsf{yes} \mid \mathsf{no}\mid \lambda(x.M)\mid \mathsf{ap}(M_1 ; M_2) \mid \Lambda(X. M) \mid \mathsf{Ap}(M ; A)")

here ![A](https://latex.codecogs.com/svg.image?A "A") is type and
![M](https://latex.codecogs.com/svg.image?M "M") is term. Of course we
have different lambda.
![\\mathsf{ap}](https://latex.codecogs.com/svg.image?%5Cmathsf%7Bap%7D "\mathsf{ap}")
is the application of terms to function types.
![\\mathsf{Ap}](https://latex.codecogs.com/svg.image?%5Cmathsf%7BAp%7D "\mathsf{Ap}")
is application of concrete types to polymorphic types.

There are now new judgement for type variable
![X](https://latex.codecogs.com/svg.image?X "X"):

![\\Gamma \\vdash X \\ \\mathsf{type}](https://latex.codecogs.com/svg.image?%5CGamma%20%5Cvdash%20X%20%5C%20%5Cmathsf%7Btype%7D "\Gamma \vdash X \ \mathsf{type}")

Now, we can differentiate the context for terms and the context for
type. Bob use
![\\Delta](https://latex.codecogs.com/svg.image?%5CDelta "\Delta") to
note the type context:
![\\Delta := X_1\\ \\mathsf{type}, X_2 \\ \\mathsf{type}, \\dots](https://latex.codecogs.com/svg.image?%5CDelta%20%3A%3D%20X_1%5C%20%5Cmathsf%7Btype%7D%2C%20X_2%20%5C%20%5Cmathsf%7Btype%7D%2C%20%5Cdots "\Delta := X_1\ \mathsf{type}, X_2 \ \mathsf{type}, \dots").
And ![\\Delta](https://latex.codecogs.com/svg.image?%5CDelta "\Delta")
is written under the vdash symbol. For example
![\\Gamma \\vdash \_{\\Delta} M : A](https://latex.codecogs.com/svg.image?%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20M%20%3A%20A "\Gamma \vdash _{\Delta} M : A").

Anyway here is the rules for the statics:

![\\mathrm{VAR} \\ \\frac{}{ \\Gamma , x :A \\vdash \_{\\Delta} x : A} \\quad \\mathrm{YES} \\ \\frac{}{\\Gamma\\vdash \_{\\Delta} \\mathsf{yes} : \\mathsf{ans}}\\quad \\mathrm{NO}\\ \\frac{}{\\Gamma \\vdash \_{\\Delta} \\mathsf{no}: \\mathsf{ans}}](https://latex.codecogs.com/svg.image?%5Cmathrm%7BVAR%7D%20%5C%20%5Cfrac%7B%7D%7B%20%5CGamma%20%2C%20x%20%3AA%20%5Cvdash%20_%7B%5CDelta%7D%20x%20%3A%20A%7D%20%5Cquad%20%5Cmathrm%7BYES%7D%20%5C%20%5Cfrac%7B%7D%7B%5CGamma%5Cvdash%20_%7B%5CDelta%7D%20%5Cmathsf%7Byes%7D%20%3A%20%5Cmathsf%7Bans%7D%7D%5Cquad%20%5Cmathrm%7BNO%7D%5C%20%5Cfrac%7B%7D%7B%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20%5Cmathsf%7Bno%7D%3A%20%5Cmathsf%7Bans%7D%7D "\mathrm{VAR} \ \frac{}{ \Gamma , x :A \vdash _{\Delta} x : A} \quad \mathrm{YES} \ \frac{}{\Gamma\vdash _{\Delta} \mathsf{yes} : \mathsf{ans}}\quad \mathrm{NO}\ \frac{}{\Gamma \vdash _{\Delta} \mathsf{no}: \mathsf{ans}}")

![\\mathrm{Lam}\\ \\frac{\\Gamma , x :A_1 \\vdash \_{\\Delta} M_2 : A_2}{\\Gamma \\vdash \_{\\Delta} \\lambda(x.M_2) : A_1 \\to A_2}\\quad \\mathrm{App}\\ \\frac{\\Gamma \\vdash \_{\\Delta} M_1 : A_2 \\to A \\quad \\Gamma \\vdash \_{\\Delta} M_2 : A_2}{\\Gamma \\vdash \\mathsf{ap}(M_1 ; M_2) : A}](https://latex.codecogs.com/svg.image?%5Cmathrm%7BLam%7D%5C%20%5Cfrac%7B%5CGamma%20%2C%20x%20%3AA_1%20%5Cvdash%20_%7B%5CDelta%7D%20M_2%20%3A%20A_2%7D%7B%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20%5Clambda%28x.M_2%29%20%3A%20A_1%20%5Cto%20A_2%7D%5Cquad%20%5Cmathrm%7BApp%7D%5C%20%5Cfrac%7B%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20M_1%20%3A%20A_2%20%5Cto%20A%20%5Cquad%20%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20M_2%20%3A%20A_2%7D%7B%5CGamma%20%5Cvdash%20%5Cmathsf%7Bap%7D%28M_1%20%3B%20M_2%29%20%3A%20A%7D "\mathrm{Lam}\ \frac{\Gamma , x :A_1 \vdash _{\Delta} M_2 : A_2}{\Gamma \vdash _{\Delta} \lambda(x.M_2) : A_1 \to A_2}\quad \mathrm{App}\ \frac{\Gamma \vdash _{\Delta} M_1 : A_2 \to A \quad \Gamma \vdash _{\Delta} M_2 : A_2}{\Gamma \vdash \mathsf{ap}(M_1 ; M_2) : A}")

![\\mathrm{LAM} \\ \\frac{\\Gamma \\vdash \_{\\Delta, X \\ \\mathsf{type}} M : A}{\\Gamma \\vdash \_{\\Delta} \\Lambda(X.M) : \\forall (X.A)} \\quad \\mathrm{APP} \\ \\frac{\\Gamma\\vdash\_{\\Delta} M : \\forall (X. B) \\quad \\Delta \\vdash A \\ \\mathsf{type}}{\\Gamma\\vdash \_{\\Delta} \\mathsf{Ap}(M ; A) : \[A/X\]B}](https://latex.codecogs.com/svg.image?%5Cmathrm%7BLAM%7D%20%5C%20%5Cfrac%7B%5CGamma%20%5Cvdash%20_%7B%5CDelta%2C%20X%20%5C%20%5Cmathsf%7Btype%7D%7D%20M%20%3A%20A%7D%7B%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20%5CLambda%28X.M%29%20%3A%20%5Cforall%20%28X.A%29%7D%20%5Cquad%20%5Cmathrm%7BAPP%7D%20%5C%20%5Cfrac%7B%5CGamma%5Cvdash_%7B%5CDelta%7D%20M%20%3A%20%5Cforall%20%28X.%20B%29%20%5Cquad%20%5CDelta%20%5Cvdash%20A%20%5C%20%5Cmathsf%7Btype%7D%7D%7B%5CGamma%5Cvdash%20_%7B%5CDelta%7D%20%5Cmathsf%7BAp%7D%28M%20%3B%20A%29%20%3A%20%5BA%2FX%5DB%7D "\mathrm{LAM} \ \frac{\Gamma \vdash _{\Delta, X \ \mathsf{type}} M : A}{\Gamma \vdash _{\Delta} \Lambda(X.M) : \forall (X.A)} \quad \mathrm{APP} \ \frac{\Gamma\vdash_{\Delta} M : \forall (X. B) \quad \Delta \vdash A \ \mathsf{type}}{\Gamma\vdash _{\Delta} \mathsf{Ap}(M ; A) : [A/X]B}")

Notice that it is safe to say that type variable in
![\\Delta](https://latex.codecogs.com/svg.image?%5CDelta "\Delta") might
appear in the type in
![\\Gamma](https://latex.codecogs.com/svg.image?%5CGamma "\Gamma"). So
you may see expression like
![\[A/X\]\\Gamma](https://latex.codecogs.com/svg.image?%5BA%2FX%5D%5CGamma "[A/X]\Gamma").

Substi and weakening now should be defined
![\\Delta](https://latex.codecogs.com/svg.image?%5CDelta "\Delta") and
type. The substi is kinda \"meta\" which is something that is non
axiomatic, and concrete.

1.  ![\\Delta \\vdash A\\ \\mathsf{type}](https://latex.codecogs.com/svg.image?%5CDelta%20%5Cvdash%20A%5C%20%5Cmathsf%7Btype%7D "\Delta \vdash A\ \mathsf{type}")
    then
    ![\\Delta, X \\ \\mathsf{type} \\vdash A \\ \\mathsf{type}](https://latex.codecogs.com/svg.image?%5CDelta%2C%20X%20%5C%20%5Cmathsf%7Btype%7D%20%5Cvdash%20A%20%5C%20%5Cmathsf%7Btype%7D "\Delta, X \ \mathsf{type} \vdash A \ \mathsf{type}")
2.  ![\\Gamma \\vdash \_{\\Delta} N : B](https://latex.codecogs.com/svg.image?%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20N%20%3A%20B "\Gamma \vdash _{\Delta} N : B"),
    then
    ![\\Gamma \\vdash \_{\\Delta, X \\ \\mathsf{type}}N : B](https://latex.codecogs.com/svg.image?%5CGamma%20%5Cvdash%20_%7B%5CDelta%2C%20X%20%5C%20%5Cmathsf%7Btype%7D%7DN%20%3A%20B "\Gamma \vdash _{\Delta, X \ \mathsf{type}}N : B")
3.  ![\\Delta\\vdash A](https://latex.codecogs.com/svg.image?%5CDelta%5Cvdash%20A "\Delta\vdash A")
    and
    ![\\Delta, X \\ \\mathsf{type}](https://latex.codecogs.com/svg.image?%5CDelta%2C%20X%20%5C%20%5Cmathsf%7Btype%7D "\Delta, X \ \mathsf{type}"),
    then
    ![\\Delta \\vdash \[A / X\]B \\ \\mathsf{type}](https://latex.codecogs.com/svg.image?%5CDelta%20%5Cvdash%20%5BA%20%2F%20X%5DB%20%5C%20%5Cmathsf%7Btype%7D "\Delta \vdash [A / X]B \ \mathsf{type}")
4.  ![\\Delta \\vdash A \\ \\mathsf{type}](https://latex.codecogs.com/svg.image?%5CDelta%20%5Cvdash%20A%20%5C%20%5Cmathsf%7Btype%7D "\Delta \vdash A \ \mathsf{type}")
    and
    ![\\Gamma\\vdash \_{\\Delta, X \\ \\mathsf{type}} N : B](https://latex.codecogs.com/svg.image?%5CGamma%5Cvdash%20_%7B%5CDelta%2C%20X%20%5C%20%5Cmathsf%7Btype%7D%7D%20N%20%3A%20B "\Gamma\vdash _{\Delta, X \ \mathsf{type}} N : B")
    then
    ![\[A / X\] \\Gamma \\vdash \_{\\Delta} \[A / X\] N : \[A / X\] B](https://latex.codecogs.com/svg.image?%5BA%20%2F%20X%5D%20%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20%5BA%20%2F%20X%5D%20N%20%3A%20%5BA%20%2F%20X%5D%20B "[A / X] \Gamma \vdash _{\Delta} [A / X] N : [A / X] B")
5.  ![\\Gamma \\vdash \_{\\Delta} M : A](https://latex.codecogs.com/svg.image?%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20M%20%3A%20A "\Gamma \vdash _{\Delta} M : A")
    and
    ![\\Gamma, x : A\\vdash \_{\\Delta} N : B](https://latex.codecogs.com/svg.image?%5CGamma%2C%20x%20%3A%20A%5Cvdash%20_%7B%5CDelta%7D%20N%20%3A%20B "\Gamma, x : A\vdash _{\Delta} N : B"),
    then
    ![\\Gamma \\vdash \_{\\Delta} \[M /x \] N : B](https://latex.codecogs.com/svg.image?%5CGamma%20%5Cvdash%20_%7B%5CDelta%7D%20%5BM%20%2Fx%20%5D%20N%20%3A%20B "\Gamma \vdash _{\Delta} [M /x ] N : B").

Here is the dynamics for system F

![\\mathrm{YES} \\ \\frac{}{\\mathsf{yes} \\ \\mathsf{final}}\\quad \\mathrm{NO}\\ \\frac{}{\\mathsf{no}}\\ \\mathsf{final}](https://latex.codecogs.com/svg.image?%5Cmathrm%7BYES%7D%20%5C%20%5Cfrac%7B%7D%7B%5Cmathsf%7Byes%7D%20%5C%20%5Cmathsf%7Bfinal%7D%7D%5Cquad%20%5Cmathrm%7BNO%7D%5C%20%5Cfrac%7B%7D%7B%5Cmathsf%7Bno%7D%7D%5C%20%5Cmathsf%7Bfinal%7D "\mathrm{YES} \ \frac{}{\mathsf{yes} \ \mathsf{final}}\quad \mathrm{NO}\ \frac{}{\mathsf{no}}\ \mathsf{final}")

![\\mathrm{App} \\ \\frac{M_1 \\longmapsto M_1 \' }{\\mathsf{ap}(M_1 ; M_2) \\longmapsto \\mathsf{ap}(M_1\' ; M_2)}\\quad \\mathrm{App}\\text{-}\\mathrm{Lam}\\ \\frac{}{\\mathsf{ap}(\\lambda(x.M); M_2) \\longmapsto \[M_2 / x\] M}](https://latex.codecogs.com/svg.image?%5Cmathrm%7BApp%7D%20%5C%20%5Cfrac%7BM_1%20%5Clongmapsto%20M_1%20%27%20%7D%7B%5Cmathsf%7Bap%7D%28M_1%20%3B%20M_2%29%20%5Clongmapsto%20%5Cmathsf%7Bap%7D%28M_1%27%20%3B%20M_2%29%7D%5Cquad%20%5Cmathrm%7BApp%7D%5Ctext%7B-%7D%5Cmathrm%7BLam%7D%5C%20%5Cfrac%7B%7D%7B%5Cmathsf%7Bap%7D%28%5Clambda%28x.M%29%3B%20M_2%29%20%5Clongmapsto%20%5BM_2%20%2F%20x%5D%20M%7D "\mathrm{App} \ \frac{M_1 \longmapsto M_1 ' }{\mathsf{ap}(M_1 ; M_2) \longmapsto \mathsf{ap}(M_1' ; M_2)}\quad \mathrm{App}\text{-}\mathrm{Lam}\ \frac{}{\mathsf{ap}(\lambda(x.M); M_2) \longmapsto [M_2 / x] M}")

![\\mathrm{APP} \\ \\frac{M\\longmapsto M\'}{\\mathsf{Ap}(M;A)\\longmapsto \\mathsf{Ap}(M\'; A)}\\quad \\text{APP-LAM} \\frac{}{\\mathsf{Ap}(\\Lambda(X.M); A) \\longmapsto \[A/X\]M}](https://latex.codecogs.com/svg.image?%5Cmathrm%7BAPP%7D%20%5C%20%5Cfrac%7BM%5Clongmapsto%20M%27%7D%7B%5Cmathsf%7BAp%7D%28M%3BA%29%5Clongmapsto%20%5Cmathsf%7BAp%7D%28M%27%3B%20A%29%7D%5Cquad%20%5Ctext%7BAPP-LAM%7D%20%5Cfrac%7B%7D%7B%5Cmathsf%7BAp%7D%28%5CLambda%28X.M%29%3B%20A%29%20%5Clongmapsto%20%5BA%2FX%5DM%7D "\mathrm{APP} \ \frac{M\longmapsto M'}{\mathsf{Ap}(M;A)\longmapsto \mathsf{Ap}(M'; A)}\quad \text{APP-LAM} \frac{}{\mathsf{Ap}(\Lambda(X.M); A) \longmapsto [A/X]M}")

**lemma 2** preservation. If
![\\vdash \_{\\varnothing} M : A](https://latex.codecogs.com/svg.image?%5Cvdash%20_%7B%5Cvarnothing%7D%20M%20%3A%20A "\vdash _{\varnothing} M : A")
and
![M \\longmapsto M\'](https://latex.codecogs.com/svg.image?M%20%5Clongmapsto%20M%27 "M \longmapsto M'")
then
![\\vdash \_{\\varnothing} M\' : A](https://latex.codecogs.com/svg.image?%5Cvdash%20_%7B%5Cvarnothing%7D%20M%27%20%3A%20A "\vdash _{\varnothing} M' : A").

# Termination Proof

For that there is another context
![\\Delta](https://latex.codecogs.com/svg.image?%5CDelta "\Delta"). So a
closed term is more than just a term where
![\\Gamma = \\varnothing](https://latex.codecogs.com/svg.image?%5CGamma%20%3D%20%5Cvarnothing "\Gamma = \varnothing"),
it is also needed that
![\\Delta = \\varnothing](https://latex.codecogs.com/svg.image?%5CDelta%20%3D%20%5Cvarnothing "\Delta = \varnothing").

So we have to talk about closed substi for type varaible
![\\delta : \\Delta](https://latex.codecogs.com/svg.image?%5Cdelta%20%3A%20%5CDelta "\delta : \Delta"),
which map variables in
![\\Delta](https://latex.codecogs.com/svg.image?%5CDelta "\Delta") to a
closed type terms.

**Theorem 3** if
![\\Gamma\\vdash \_{\\Delta} M : A](https://latex.codecogs.com/svg.image?%5CGamma%5Cvdash%20_%7B%5CDelta%7D%20M%20%3A%20A "\Gamma\vdash _{\Delta} M : A"),
then given closed
![\\delta : \\Delta](https://latex.codecogs.com/svg.image?%5Cdelta%20%3A%20%5CDelta "\delta : \Delta")
and closed
![\\gamma : \\Gamma](https://latex.codecogs.com/svg.image?%5Cgamma%20%3A%20%5CGamma "\gamma : \Gamma"),
we have that the instance
![\\hat \\gamma (\\hat \\delta( M))](https://latex.codecogs.com/svg.image?%5Chat%20%5Cgamma%20%28%5Chat%20%5Cdelta%28%20M%29%29 "\hat \gamma (\hat \delta( M))")
is hereditarily terminating of type
![\\hat \\delta(A)](https://latex.codecogs.com/svg.image?%5Chat%20%5Cdelta%28A%29 "\hat \delta(A)").

Proof: You can\'t proof it. There is a problem: say a term
![M](https://latex.codecogs.com/svg.image?M "M") has type
![A](https://latex.codecogs.com/svg.image?A "A"), which is of form
![\\Lambda(X.B)](https://latex.codecogs.com/svg.image?%5CLambda%28X.B%29 "\Lambda(X.B)"),
you need to prove that for all type
![C](https://latex.codecogs.com/svg.image?C "C") that
![\\mathsf{Ap}(M; C) : \[C/X\]B](https://latex.codecogs.com/svg.image?%5Cmathsf%7BAp%7D%28M%3B%20C%29%20%3A%20%5BC%2FX%5DB "\mathsf{Ap}(M; C) : [C/X]B")
has
![\\mathsf{HT}](https://latex.codecogs.com/svg.image?%5Cmathsf%7BHT%7D "\mathsf{HT}").

But, this \"all type ![C](https://latex.codecogs.com/svg.image?C "C")\"
includes exactly ![A](https://latex.codecogs.com/svg.image?A "A")
itself. And that is fucked up. For example when
![A = \\forall (X . X \\to X)](https://latex.codecogs.com/svg.image?A%20%3D%20%5Cforall%20%28X%20.%20X%20%5Cto%20X%29 "A = \forall (X . X \to X)"),
when applying it to itself, we have
![A \\to A](https://latex.codecogs.com/svg.image?A%20%5Cto%20A "A \to A").
It becomes bigger. Induction does not work here.

Bob went to saying a lot of things. But the thing is that some kind of
\"constrain\" is needed for proving the theorem. The problem is that
what \"constrain\" and \"where\".

Bob uses the word \"specification\", and moreover, we need \"behavioral
specification\". A property that would be not be changed under weak head
expansion, which \"closed under weak head expansion\".

The proof can be checked in Girard\'s book *Proofs and Types*, but the
writing of Girard is also quite demanding (though significantly more
friendly than The Blind Spot and later works).

The main idea is to introduce \"reducible candidate\". And we talk about
another kind of map that maps types to reducible candidates, terms that
are terminating.
![\\eta](https://latex.codecogs.com/svg.image?%5Ceta "\eta") is now a
map related to
![\\delta : \\Delta](https://latex.codecogs.com/svg.image?%5Cdelta%20%3A%20%5CDelta "\delta : \Delta").
We write it as
![\\eta \\subset \\delta : \\Delta](https://latex.codecogs.com/svg.image?%5Ceta%20%5Csubset%20%5Cdelta%20%3A%20%5CDelta "\eta \subset \delta : \Delta").

Def. A *Candidate* for type
![A](https://latex.codecogs.com/svg.image?A "A") is a set of terms
closed under head expansion.

Def.
![\\eta \\subseteq \\delta : \\Delta](https://latex.codecogs.com/svg.image?%5Ceta%20%5Csubseteq%20%5Cdelta%20%3A%20%5CDelta "\eta \subseteq \delta : \Delta")
is a map. It would map
![\\delta(X)](https://latex.codecogs.com/svg.image?%5Cdelta%28X%29 "\delta(X)")
to a candidate of type
![\\delta(X)](https://latex.codecogs.com/svg.image?%5Cdelta%28X%29 "\delta(X)").
